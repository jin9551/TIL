# S3 버킷과 오브젝트


 **버킷과 객체(Object)** 개념을 딱 정리해 줄게요. 군더더기 없이 핵심만, 하지만 필요한 디테일은 다 넣었습니다.

# 1) 버킷(Bucket): “컨테이너 + 정책의 경계”

* **정의**: S3에서 데이터를 담는 최상위 컨테이너. 모든 객체는 정확히 하나의 버킷에 속함.
* **영역성(Region‐scoped)**: 버킷은 특정 리전에 생성됨. 지연, 요금, 규제 대응에 영향.
* **이름 규칙**: 전 세계에서 **고유**해야 함, 소문자/숫자/하이픈/점, 길이 3–63자.
  (버킷 이름에 `.`이 있으면 HTTPS + 가상호스팅 시 인증서 SAN 이슈 생길 수 있음)
* **정책/보안의 경계**

  * **버킷 정책**, **S3 Object Ownership(ACL 비활성화)**, **Block Public Access**로 접근 관리.
  * **기본 암호화**(SSE-S3/SSE-KMS) 설정 지점.
* **데이터 거버넌스의 홈**

  * **버전관리(Versioning)** on/off
  * **수명주기(Lifecycle)**: 클래스 전환(IA/Glacier), 만료/삭제
  * **복제(Replication)**: 동일/교차 리전 복제
  * **이벤트**: EventBridge/SNS/SQS/Lambda 통지
  * **로깅/인벤토리/요청자 지불(Requester Pays)** 등
* **정적 웹 호스팅**: 사이트 인덱스/에러 문서 지정 가능(권장: CloudFront와 함께 사용).

> 한마디로, **버킷은 보안·정책·거버넌스와 리전 스코프를 정의하는 컨테이너**입니다.

---

# 2) 객체(Object): “데이터 그 자체 + 메타정보”

* **정의**: S3에 저장되는 단일 데이터 단위. 파일이라고 보면 됨.
* **구성**:
  `데이터 바디 + 메타데이터(시스템/사용자 정의) + 키(Key) + 스토리지 클래스 + 태그 + 버전ID(옵션)`
* **키(Key)**: 버킷 내 유일한 식별자. 경로처럼 보이지만 **폴더 개념은 없음**(프리픽스/구분자만 있을 뿐).
  예) `images/2025/08/profile.jpg` ⇒ `images/2025/08/`는 “가짜 폴더(프리픽스)”
* **크기/업로드**: 최대 **5TB**. 단일 PUT은 5GB 이하 권장, 그 이상/대부분 대용량은 **멀티파트 업로드** 사용.
* **메타데이터**

  * **시스템**: Content-Type, Content-Length, ETag(단일 PUT이면 대개 MD5), 체크섬 등
  * **사용자 정의**: `x-amz-meta-*` 형태의 커스텀 키/값
  * **태그(TAG)**: 최대 10개(키/값). 수명주기/권한/비용 분류에 활용.
* **스토리지 클래스**: Standard/IA/One Zone-IA/Glacier/Deep Archive 등 **객체 단위**로 선택 가능.
* **암호화**: SSE-S3, **SSE-KMS**, SSE-C 또는 클라이언트측. 버킷 기본 암호화가 있으면 자동 적용.
* **불변성/교체**: 객체는 **부분 수정 불가**. 새로 덮어쓰기(Overwrite)하거나 **버전관리**로 새 버전이 생김.
* **무결성**: ETag는 멀티파트 업로드일 때 **MD5가 아닐 수 있음**. 요즘은 \*\*체크섬(sha256/CRC 등)\*\*도 지원.
* **프리사인 URL**: 제한 시간 동안 서명 URL로 안전한 다운로드/업로드 허용.

> 요약하면, **객체는 실제 데이터와 그 특성(메타/암호화/클래스/태그)을 담은 불변 단위**입니다.

---

# 3) 버킷 vs 객체 — 역할 한눈에 비교

| 구분    | 버킷(Bucket)                  | 객체(Object)                    |
| ----- | --------------------------- | ----------------------------- |
| 스코프   | 리전 단위, 전역 고유 이름             | 버킷 내부의 개별 데이터                 |
| 핵심 역할 | 정책/보안/거버넌스/이벤트/수명주기         | 데이터 + 메타데이터/태그/클래스            |
| 식별    | 버킷 이름(전역 유일)                | 키(Key, 버킷 내 유일)               |
| 일관성   | **강한 일관성**(리스트 포함)          | 생성/삭제/덮어쓰기 후 **즉시** 일관 조회     |
| 변경 방식 | 설정/정책 변경 중심                 | 덮어쓰기=새 객체(버전관리 시 과거 버전 유지)    |
| 비용 관점 | 대부분 저장·요청·전송 합산(정책/이벤트는 메타) | 저장 용량, 요청 수, 스토리지 클래스/수명주기 영향 |

---

# 4) 자주 겪는 함정(Gotchas)

* **폴더 착각**: S3 “폴더”는 실제 디렉터리가 아니라 **키 프리픽스**일 뿐. 권한/수명주기는 **프리픽스/태그**로 제어.
* **ETag 오해**: 멀티파트 업로드면 ETag ≠ MD5. 무결성 검증은 **체크섬**으로.
* **퍼블릭 차단**: 새 버킷은 대개 **Block Public Access**가 기본. 정적 웹 배포 시 정책/CloudFront 설정 필요.
* **버전관리 삭제**: 삭제는 **Delete Marker**를 얹는 것. 과거 버전은 별도 삭제해야 실제 용량 감소.
* **점(.) 있는 버킷명**: `my.bucket`은 HTTPS 가상호스팅 시 인증서 매칭 이슈 가능.
* **성능**: 예전처럼 키 프리픽스 분산을 의식적으로 설계할 필요는 거의 없음(자동 파티셔닝). 다만 **동일 키에 고QPS**는 병목.

---

# 5) 키/프리픽스 설계 팁

* **쿼리/수명주기 단위**로 **프리픽스**를 잡아라: 예) `logs/appA/yyyymmdd/…`
* 비용/보안/보존정책을 분리하고 싶다면 **객체 태그**를 같이 활용.
* 대량 리스트가 잦으면 접두어로 파티셔닝해 **ListObjectsV2 + Prefix/Delimiter**를 효율화.

---
