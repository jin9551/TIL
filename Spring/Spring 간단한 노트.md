# Spring

## 계층

스프링에서는 3가지 계층이 존재한다.

* 프레젠테이션 계층 : HTTP 요청을 받고 이 요청을 비즈니스 계층으로 전송하는 역할. 컨트롤러가 이 역할을 함
* 비즈니스 계층 : 모든 비즈니스 로직을 처리한다. 서비스가 이 역할을 함.
* 퍼시스턴스 계층 : 모든 데이터베이스 관련 로직을 처리한다. 이 과정에서 데이터베이스에 접근하는 Dao객체를 사용할 수 있다. 레포지토리가 이 역할을 한다.

## 스프링 응답 과정
1. 클라이언가 톰캣에 요청
2. 스프링의 디스패처 서블릿이 URL을 분석하고 요청을 처리할 컨트롤러를 찾아 요청 전달
3. 컨트롤러 내에 있는 메서드와 요청이 매치
4. 비즈니스 계층과 퍼시스턴스 계층을 통하여 필요한 작업을 함.
5. 뷰 리졸버가 HTML문서를 만들거나 Json, XML등의 데이터를 생성

* * *

## 제어의 역전과 의존성 주입

### IOC(Inversion of Control)
기존의 전통적인 프로그래밍 모델에서는 개발자가 코드의 제어 흐름을 직접 관리했다.
IoC는 반대로 프레임워크나 컨테이너가 코드의 제어 흐름을 가져가도록 하는 것을 의미한다.

즉, 객체 생성을 해당 객체에서 의존하는 객체가 직접 new 키워드와 생성자를 이용하여 하는 것이 아니라,
객체를 필요로 한다는 일종의 힌트(어노테이션)만 붙여주면 외부에서 해당 객체를 만들어 주입하는 전략이다.


### DI(Dependency Injection)
스프링에서는 객체들을 관리하기 위하여 제어의 역전을 사용한다. 그리고 제어의 역전을 구현하기 위해
사용하는 방법이 DI이다. 의존성은 어떤 클래스가 다른 클래스에 의존한다는 뜻.
의존성 주입(DI)는 객체를 직접 만들지 않고 외부에서 주입해 주는 디자인 패턴을 의미한다.
DI를 통해 객체간의 결합도를 줄이고 코드의 재사용성을 높일 수 있다.

#### DI를 하는 세 가지 방법

1. 생성자 주입 (Constructor Injection)
생성자 주입은 객체를 생성할 때, 생성자를 통해 의존성을 주입하는 방식
스프링에서 생성자에 @Autowired 어노테이션을 사용하여 의존성을 주입한다. 또는 XML 설정 파일에서 
<contructor-arg> 요소를 사용할 수도 있다.
생성자 주입은 필수적인 의존성을 명시적으로 표현할 수 있고, 불변성을 보장하여 안정적인 객체를 생성할 수 있다.

2. Setter 주입 (Setter Injection)
Setter 주입은 객체 생성 후 Setter 메서드를 통해 의존성을 주입하는 방식
스프링에서 Setter 메서드에 @Autowired를 사용하여 의존성 주입 혹은 XML 설정에서 <property> 요소 사용 가능
Setter 주입은 선택적인 의존성을 표현하기에 유용

3. 필드 주입 (Field Injection)
필드 주입은 필드에 바로 의존성을 주입하는 방식
스프링에서 필드에 @Autowired를 사용하여 의존성 주입

여러 방법을 쓰는 것은 중복 주입이 이루어지므로 지양해야한다.
보통 생성자를 통해 의존성 주입을 하는 것이 가장 좋은 방법. 생성자 주입을 통해서만 의존성 주입을 받는 필드를 상수로 정의할 수 있음.

* * *

## Bean과 스프링 컨테이너 

스프링은 애플리케이션의 객체 생성과 관리를 담당하는 스프링 컨테이너와 이를 통해 관리되는 객체를 빈(Bean)이라고 부른다.

### Bean

빈은 스프링 컨테이너에 의해 생성되고 관리되는 객체를 말한다. 스프링에서 개발자가 작성한 일반적인 자바 클래스를 빈으로 등록하여 사용할 수 있다.

빈은 XML 설정 파일이나 Java Config, 어노테이션을 통해 정의될 수 있다.

#### Bean을 등록하는 방법

1. XML 기반
XML 파일에 <bean> 요소를 사용하여 Bean을 정의한다. 일반적으로 application-context.xml 또는 beans.xml과 같은 이름의 XML파일을 사용한다.

2. Java Config 기반
자바 클래스에 @Configuration 애노테이션을 사용하여 설정 클래스를 정의하고 @Bean 애노테이션을 사용하여 Bean을 정의하는 방법

3. Component Scanning 기반(어노테이션 기반)
@Component, @Service, @Repository, @Controller 등의 스프링 어노테이션을 사용하여 클래스를 표시하고, 스프링이 자동으로 Bean으로 등록하는 방법. 스프링 컨테이너는 클래스 경로에서 이러한 애노테이션이 지정된 클래스를 검색하고 자동으로 Bean으로 등록


### Spring IoC Container
스프링 컨테이너는 스프링 프레임워크의 핵심으로, 애플리케이션의 객체를 생성, 관리, 조립하는 역할을 담당한다.
Application Context 인터페이스를 구현한 객체가 스프링 IoC 컨테이너의 역할을 수행한다.
Application Context는 스프링에서 제공하는 IoC 컨테이너로, 생성된 Bean을 보관하는 역할을 수행한다.

> 갑자기 기억나서 적는 거
>> application-context.xml = root-context.xml = 전통적인 스프링 전역 bean 설정 파일 DB, 서비스, dao 등
>> servlet-context.xml - 웹 전용 설정 (MVC) = controller, view resolver 등

* * *

## 관점 지향 프로그래밍 (AOP, Aspect-Oriented Programming)

AOP란 프로그래밍에 대한 관점을 핵심 관점, 부가 관점으로 나누어서 관심 기준으로 모듈화하는 것을 의미한다.
여기서 관점(Aspect)란 부가 기능과 그 적용처를 정의하고 합쳐서 모듈로 만든 것.
> 간단하게 말하자면 프로그램의 여러 곳에서 공통적으로 사용되는 부분을 모아서 하나의 모듈로 만드는 것.

### AOP의 목적

관점 지향 프로그래밍은 객체 지향 프로그래밍(OOP)를 보완하기 위해 사용된다. 기존 객체 지향은 목적에 따라 객체를 만들었다. 따라서 핵심 비즈니스, 부가 비즈니스이든 객체로 분리하는데 그치고, 그 객체들을 어떻게 바라보고 나눠 쓸지에 대한 정의가 부족하다는 단점이 있다. 이를 보완하기 위해 AOP를 사용한다.

* * *

## ORM

ORM(객체 관계 매핑, Object-Relational Mapping)은 객체 지향 프로그래밍 언어와 관계형 데이터베이스 간의 데이터를 변환하는 기술이며, 객체 모델과 데이터베이스 모델 간의 불일치를 해결하기 위해 사용된다.

일반적으로 객체는 클래스와 속성(attribute)로 구성되어 있고, 데이터베이스는 테이블과 열(column)로 구성되어 있다. ORM은 이러한 객체와 데이터베이스 간의 불일치를 ㅎ결하기 위해, 객체를 데이터베이스 테이블에 매핑하고, 객체 간의 관계를 데이터베이스의 관게로 매핑한다. 

> DTO에 DB 테이블의 열을 따라서 변수를 작성하는 것을 연상하면 된다.

* * *

## JPA (Java Persistence API)

ORM에도 여러 종류가 있는데, 그 중 자바에서 표준으로 쓰는 것은 JPA이다. JPA는 자바에서 관계형 데이터베이스를 사용하는 방식으로 정의한 인터페이스인데, 실제 사용을 위해서는 ORM 프레임워크를 추가로 선택해야 한다. 대표적인 프레임워크는 하이버네이트다.

하이버네이트는 JPA 인터페이스를 구현한 구현체이자 자바용 ORM 프레임워크이다. 하이버네이트 내부적으로는 JDBC API를 사용한다. 하이버네이트의 목표는 자바 객체를 통해 데이터베이스 종류에 상관없이 데이터베이스를 자유롭게 사용할 수 있게 하는 것이다.

> JPA는 자바 객체와 데이터베이스를 연결해 데이터를 관리한다. 객체 지향 도메인 모델과 데이터베이스의 다리 역할
> 하이버네이트는 JPA의 인터페이스를 구현. 내부적으로 JDBC API를 사용한다.

### 엔티티 매니저

JPA의 중요한 컨셉으로는 엔티티 메니저와 영속성 컨텍스트를 알아야한다.

* 엔티티 (Entity)
엔티티는 데이터베이스의 테이블과 매핑되는 객체를 의미한다. 엔티티는 본질적으로는 자바 객체이므로 일반 객체와 다르지 않다. 하지만 DB의 테이블과 직접 연결된다는 특징이 있어 구분지어 부른다. 즉, 엔티티는 객체이지만 데이터베이스에 영향을 미치는 쿼리를 실행하는 객체이다.

* 엔티티 매니저 (Entity Manager)
엔티티 매니저는 엔티티를 관리해 애플리케이션 사이에서 객체를 생성, 수정, 삭제하는 등의 역할을 한다. 그리고 이런 엔티티 매니저를 만드는 곳이 엔티티 매니저 팩토리이다.

DB에는 여러 사용자가 접근할 수 있다. 예시로 2명의 회원이 동시에 회원 가입을 하려는 경우 엔티티 매니저 팩토리는 각각의 업무에 대해 엔티티 매니저를 생성한다. 업무마다 생성된 엔티티 매니저를 통해 회원의 정보가 DB에 저장된다. 그리고 필요한 시점에 DB와 연결한 뒤 쿼리한다.

스프링 내부에서는 엔티티 매니저 팩토리를 하나만 생성해서 관리하고 @PersistanceContext 또는 @Autowired 어노테이션을 사용해 엔티티 매니저를 사용한다.

``` java
@PersistenceContext
EntityManager em;
```

그리고 스프링은 기본적으로 빈을 하나만 생성해서 공유하므로 동시성 문제가 발생할 수 있다. 그래서 실제로 엔티티 매니저가 아닌 실제 엔티티 매니저와 연결하는 프록시(가짜) 엔티티 매니저를 사용한다. 필요할 때 DB 트랜잭션과 실제 엔티티 매니저를 호출한다.

즉 엔티티 매니저는 Spring Data JPA에서 관리하므로 개발자가 직접 생성하거나 관리할 필요가 없다.

### 영속성 컨텍스트
엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장한다는 특징이 있다. 영속성 컨텍스트는 JPA의 중요한 특징 중 하나로, 엔티티를 관리하는 가상의 공간이다. 이것이 있기 때문에 DB에서 효과적으로 데이터를 가져올 수 있고, 엔티티를 편하게 사용할 수 있다.

영속성 컨텍스트에는 1차 캐시, 쓰기 지연, 변경 감지, 지연 로딩이라는 특징이 있다.
> 사실 5개다
> https://devoong2.tistory.com/entry/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8Persistence-Context%EC%9D%98-5%EA%B0%80%EC%A7%80-%ED%8A%B9%EC%A7%95

* 1차 캐시 (First level cache)
	* 영속성 컨텍스트는 내부에 1차 캐시를 가지고 있다. 
	* 이때 캐시의 키는 엔티티의 @Id 어노테이션이 달린 기본키 역할을 하는 식별자이며 값은 엔티티이다. 
	* 엔티티를 조회하면 1차 캐시에서 데이터를 조회하고 값이 있으면 반환한다. 값이 없으면 DB에서 조회해 1차 캐시에 저장한 다음 반환한다.
	* 이를 통해 캐시된 데이터를 조회할 때에는 DB를 거치지 않아도 되므로 빠르게 데이터 조회할 수 있다.

* 쓰기 지연 (transactional write-behind)
쓰기 지연은 트랜잭션을 커밋하기 전까지는 DB에 실제로 질의문을 보내지 않고 쿼리를 모았다가 트랜잭션을 커밋하면 모았던 쿼리를 한번에 실행하는 것을 의미함. 이를 통해 DB 시스템의 부담을 줄일 수 있다.

* 변경 감지 (Dirty Checking)
트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을 비교해서 변경된 값이 있다면 변경 사항을 감지해 변경된 값을 데이터베이스에 자동으로 반영함. 이를 통해 쓰기 지연과 마찬가지로 적당한 묶음으로 쿼리를 요청할 수 있고, DB 시스템의 부담을 줄일 수 있다.

* 지연 로딩 (lazy loading)
지연 로딩은 연관 관계에 있는 엔티티를 조회시 한번에 가져오지 않고 필요시에 가져 오는 것. 


### 엔티티의 상태
엔티티는 4가지 상태를 가진다.
* 1. 영속성 컨텍스트가 관리하고 있지 않는 분리(detached) 상태
* 2. 영속성 컨텍스트가 관라하고 있는 관리(managed) 상태
* 3. 영속성 컨텍스트와 전혀 관계가 없는 비영속(transit) 상태
* 4. 삭제된(removed) 상태

이 상태는 특정 메서드를 호출해 변경할 수 있고, 필요에 따라 엔티티으 ㅣ상태를 조절해 데이터를 올바르게 유지하고 관리할 수 있다.

> 참고1 :
> https://hulrud.tistory.com/110

> 참고2 :
> https://shinsunyoung.tistory.com/133
